# Decisions Log — Backend

**Source:** /specialists/backend
**Total:** 15 decisions

---

### BACK-01: REST API at /api/ prefix, auto-generated OpenAPI docs
**Category:** API Design
**Decision:** Resource-based REST endpoints under /api/. No versioning prefix (solo dev, single consumer). FastAPI auto-generates OpenAPI spec + Swagger UI at /docs.
**Alternatives:** GraphQL, gRPC, versioned /api/v1/
**Rationale:** REST is simplest for CRUD + control actions. Auto-generated docs are free with FastAPI.
**Trade-offs:** No versioning — acceptable for personal tool.

---

### BACK-02: 7 endpoint groups, ~25 endpoints total
**Category:** API Design
**Decision:** Projects (5), Templates (6), Pipeline Control (7), Phase Control (4), Artifacts (2), LLM Providers (5), WebSocket (1). Covers all workflows from project-spec.md.
**Alternatives:** Fewer endpoints with more complex payloads
**Rationale:** One endpoint per action keeps the API predictable and easy to test.
**Trade-offs:** More endpoints to maintain — manageable at this scale.

---

### BACK-03: Pagination via limit/offset query params
**Category:** API Design
**Decision:** GET list endpoints support ?limit=20&offset=0. Default limit=50, max limit=100.
**Alternatives:** Cursor-based pagination
**Rationale:** Datasets are tiny (tens of projects). Offset is simpler and sufficient.
**Trade-offs:** Offset is inefficient for large datasets — irrelevant here.

---

### BACK-04: Pydantic v2 strict mode for all request/response schemas
**Category:** Validation
**Decision:** All request bodies validated by Pydantic v2 models with strict types and custom error messages. Response models strip internal fields.
**Alternatives:** Manual validation, marshmallow
**Rationale:** Pydantic v2 is native to FastAPI. Strict mode catches type coercion bugs.
**Trade-offs:** None.

---

### BACK-05: Pipeline + phase state machine with defined transitions
**Category:** Validation
**Decision:** PipelineRun: pending→running→{paused,completed,failed,cancelled}. PhaseExecution: pending→running→{completed,failed,skipped,rolled_back}. Completed and cancelled are terminal. Invalid transitions raise WorkflowError.
**Alternatives:** Free-form status strings
**Rationale:** Explicit state machine prevents impossible states and makes transitions auditable.
**Trade-offs:** More rigid — by design.

---

### BACK-06: Three validation layers — request, service, DB
**Category:** Validation
**Decision:** Request layer (Pydantic): types, required fields, enums. Service layer (Python): business rules, cross-entity checks. DB layer (SQLite): NOT NULL, UNIQUE, FK, CHECK.
**Alternatives:** Single validation layer
**Rationale:** Defense in depth. Each layer catches different classes of errors.
**Trade-offs:** Some redundancy — worth it for reliability.

---

### BACK-07: Template validation on create/update
**Category:** Validation
**Decision:** Pydantic validates structure. Business rules: no circular phase dependencies, at least one phase, all referenced output_schemas must exist, all tool names must be registered.
**Alternatives:** Validate only on use
**Rationale:** Fail fast on invalid templates, not mid-pipeline.
**Trade-offs:** None.

---

### BACK-08: UUID primary keys, snake_case naming
**Category:** Database
**Decision:** All tables use UUID (TEXT in SQLite) as PK, generated by Python uuid4(). Table/column naming: snake_case (pipeline_runs, created_at).
**Alternatives:** Auto-increment integers, camelCase
**Rationale:** UUIDs are globally unique, safe for API exposure. Snake_case is Python convention.
**Trade-offs:** UUIDs are longer than integers — negligible impact.

---

### BACK-09: 8 core tables with typed columns, indexes, and FK constraints
**Category:** Database
**Decision:** projects, workflow_templates, pipeline_runs, phase_executions, artifacts, llm_providers, tool_calls, checkpoints. Each with appropriate indexes for query patterns.
**Alternatives:** Fewer tables with embedded JSON
**Rationale:** Normalized enough for queries, denormalized enough for simplicity. Indexes serve the frontend query patterns.
**Trade-offs:** 8 tables is moderate — manageable.

---

### BACK-10: Cascade deletes for children, RESTRICT for references, no soft delete
**Category:** Database
**Decision:** Delete project cascades to runs/executions/artifacts/tool_calls/checkpoints. Delete template is restricted if projects reference it. Hard delete only — no soft delete.
**Alternatives:** Soft delete with is_deleted flag
**Rationale:** Solo dev, no compliance. Soft delete adds complexity for no benefit.
**Trade-offs:** Deletes are permanent — acceptable for personal tool.

---

### BACK-11: Alembic migrations with descriptive names, auto-run on startup
**Category:** Database
**Decision:** Migrations named 001_initial_schema.py, 002_add_xxx.py. Auto-run on app startup. Downgrade supported.
**Alternatives:** Manual migration running, Django-style auto-detect
**Rationale:** Auto-run is safe for solo dev. Descriptive names aid debugging.
**Trade-offs:** Auto-migration risk in production — irrelevant for local tool.

---

### BACK-12: Transactional operations with post-commit side effects
**Category:** Service Layer
**Decision:** DB mutations are atomic within transactions. Side effects (LLM calls, WebSocket events, async tasks) happen post-commit only. Three key operations defined: start_pipeline, complete_phase, rollback_to_checkpoint.
**Alternatives:** Everything in one transaction, eventual consistency
**Rationale:** Clean separation: DB state is always consistent, side effects don't block transactions.
**Trade-offs:** Post-commit side effects can fail after commit — mitigated by checkpoints and retry.

---

### BACK-13: No concurrency control needed
**Category:** Service Layer
**Decision:** Single user, single concurrent run. No optimistic locking, no race condition handling.
**Alternatives:** Optimistic locking with version columns
**Rationale:** Constraint is max 1 concurrent run (GEN constraints). No contention possible.
**Trade-offs:** Can't support multiple concurrent users without adding locking — out of scope.

---

### BACK-14: Three LLM provider integrations via SDK with retry/backoff
**Category:** Integrations
**Decision:** Anthropic (anthropic SDK), OpenAI (openai SDK), Gemini (google-genai SDK). Each wrapped in LLMAdapter (ARCH-14). 429/5xx retries with exponential backoff (3 retries, 1s/2s/4s).
**Alternatives:** Raw HTTP calls, single SDK
**Rationale:** Official SDKs handle auth, streaming, serialization. Adapter pattern from ARCH-14.
**Trade-offs:** Three SDK dependencies — necessary for multi-provider support.

---

### BACK-15: Secondary LLM failure is non-blocking
**Category:** Integrations
**Decision:** Only Anthropic (primary builder) failure blocks a phase. OpenAI/Gemini failures are logged, reported in UI, but don't stop execution. Graceful degradation.
**Alternatives:** All providers required, fail-fast
**Rationale:** Second opinion is valuable but not critical. Pipeline shouldn't stall because Gemini is down.
**Trade-offs:** Reviews may be incomplete — user sees which providers responded.
